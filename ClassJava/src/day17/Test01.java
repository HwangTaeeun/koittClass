package day17;

import java.io.*;

/*
	char 단위 스트림
		==> 한번 입출력할 때 2바이트 단위로(<== char 의 사이즈가 2바이트) 입출력할 수 있는 스트림
		
		주의]
			기계어 상태의 내용은 절대로 char 단위 입출력을 사용하면 안된다.
			이 스트림은 오직 텍스트 문서에 한해서만 사용해야 한다.
			
			기계어 문서는 반드시 byte 단위의 입출력을 사용해야 한다.
			왜???
				2개의 byte가 1개의 char 가 될 때 바이트의 순서가 역전될 수 있다.
				
				예]
					가		ㄱ				ㅏ
						0011				0101
					합침		00110101	--------	x
							
								01010011	--------	o
								
								
		1. FileWriter / FileReader
			==> 파일에 직접 연결된 타겟스트림(기본스트림)
				단위는 char 단위가 된다.
				
			내부적으로 char 단위로 처리하는 것만 변경되었을 뿐
			사용자 입장에서는 byte단위의 처리와 별 차이점 없이 사용하면 된다.
				
		2. 관련된 필터 스트림
			
			1) BufferedReader / BufferedWriter
				==> 중간에 버퍼 기능을 추가해서 스트림의 성능 향상을 위한 보조 스트림
				
				참고]
					가장 핵심적인 함수
					char의 기본 함수는 문자열을 읽을 수 있는 함수가 없다.
					
					readLine()	==> 한줄로 문자열을 그대로 읽어서 사용할 수 잇는 함수
					
					참고]
						이 함수를 사용할 때 주의사항
							이 함수는 줄단위로 한줄씩 읽는 함수
							( ==> 줄 단위(\r\n)를 발견하면 그곳에서 읽는 것을 멈춘다. )
							
							필요하면 줄 단위(\r\n)를 강제로 추가해야 한다.
							이 함수는 줄바꿈기호를 삭제한다.
							( 즉, 줄단위(\r\n)전 까지 읽은 후 이 줄의 줄바꿈 기호는 버린다. )
							
			2) PrintWriter
				==> PrintStream 은 바이트단위 스트림이었고
					그것과 비슷한 기능의 문자단위 보조 스트림(필터스트림)이다.
					
					1. 버퍼의 기능을 가지고 있다.
					2. 직접 파일에 연결할 수 있다.(다른장치에도 연결 가능)
					3. 사용자의 편의를 도모한다.
						(자바의 데이터 타입을 그대로 사용한다.)
					4. 다른 byte[]의 스트림과도 연결 할 수 있다.
					
				참고]
					스트림을 연결 할 때 주의 사항
						1. 반드시 같은 방향끼리만 연결 할 수 있다.
							
							FileInputStream ---> BufferedOutputStream	: X
							FileInputStream ---> BufferedInputStream	: O
							
							
						2. 반드시 같은 크기끼리만 연결 할 수 있다.
							
							FileInputStream ----> BufferedReader		: X
							byte 기반				문자기반
					
					***	
					참고]
						InputStreamReader / OutputStreamWriter
						==> 크기가 다른 두개의 스트림을 연결할 때 사용하는 보조 스트림의 일종
						
						예]
							FileInputStream --->	InputStreamReader	---> BufferdReader
							
								byte기반				타입변환 보조		문자기반 보조
						
					참고]
						타겟(기본)이 char기반이고 보조가 byte기반이라면 연결이 되지 않는다.
						반드시
						타겟이 바이트기반이고 보조가 문자기반이어야 
							InputStreamReader / OutputStreamWriter 를
						사용할 수 있다.
						
		***
		객체의 직렬화
			==> 데이터는 자바의 기본형 이외에도 
				클래스 전체를 데이터로 상대방(외부장치)에 입출력 할 수 있다.
				
				이때 함수는 제외되고
				변수의 내용만 입출력이 된다.
				
				이처럼 클래스가 다른 장치에 전달되는 상태를 직렬화 라고 하는데....
				<== 직렬화라 하는 이유는
					클래스에 있는 변수의 내용이
					순서대로 입출력된다. 고 해서
					붙여진 이름.....
					
			***
			아무클래스나 입출력으로 사용할 수 있는 것은 아니고
			입출력에 사용할 수 있는 클래스는
			반드시 직렬화 가능한 클래스여야 한다.
			직렬화 가능한 클래스는 Serializable 인터페이스를 구현한 클래스이다.
			
			***
			문제]
				직렬화는 변수의 내용만 입출력되므로
				네트워크 환경에서 처럼 서로 떨어진 경우에는
				양쪽에 같은 클래스가 존재 해야 한다.
				왜냐하면
					클래스 구조는 전달이 되지 않고
					변수 내용만 전달이 되기 때문에
					양쪽 모두 클래스 구조를 가지고 있어야 한다.
				이때 양쪽에 있는 클래스는 
					클래스이름 + 패키지이름 까지 
				모두 동일해야 한다.
				
			이때 사용하는 보조스트림이
				ObjectInputStream / ObjectOutputStream
				==> 주로 네트워크에서 많이 사용하므로
					문자단위는 아니다.
				
				***
				주의]
					1.	ObjectOutputStream 으로 넘겨진 데이터는
						반드시 
							ObjectInputStream
						으로 읽어야 처리가 된다.
					2. 	보내는 쪽에서 클래스의 내용이 변경이 되면
						받는 쪽의 클래스 내용도 변경해서 받아야 처리 된다.
						
						
---------------------------------------------------------------------------------------------------
	IO 파트 학습 해야할 것
		1. 필요한 데이터를 파일에 저장할 수 있다.
		2. 파일에 저장된 데이터를 읽어서 사용할 수 있다.
			
				
 */

/*
	예제 1]
		문자 기반 스트림을 이용해서 
		파일에 데이터를 저장해 보자.
 */
public class Test01 {

	public Test01() {
		// 1. 타겟(기본)스트림을 준비하고
		FileWriter fw = null;
		try {
			// 2. 타겟 스트림 만들고
			fw = new FileWriter("src/day17/fwTest.txt");
			
			/*
			// 1) 문자 하나 (2byte)만 저장해보자.
			char ch = '끝';
			fw.write(ch);
			*/
			
			/*
			// 2) 여러글자를 문자 배열을 이용해서 저장해 보자.
			
			// a. 문자열을 만들고
			String str = "jFla 좋아요! 정말 좋아요!";
			
			// b. 문자 배열 만들고
			char[] buff = str.toCharArray();
			fw.write(buff);
			*/
			
			// 3) 여러글자를 문자열을 이용해서 저장해 보자.
			// a. 문자열 만들고
			String str = "jFla 좋아요! 정말 좋아요!\r\n";
			str += "송림씨도 무지 좋아 합니다.";
			// b. 문자열을 저장하고
			fw.write(str);
			
			
			System.out.println("### 빨래 끝 ~~~! ###");
		} catch(Exception e) {
			e.printStackTrace();
		} finally {
			try {
				fw.close();
			}catch(Exception e) {}
		}
	}

	public static void main(String[] args) {
		new Test01();
	}

}
