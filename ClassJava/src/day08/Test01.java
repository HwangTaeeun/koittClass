package day08;

public class Test01 {
/*
	생성자 함수가 여러개 있다는 이야기는
	==> 그 클래스의 객체를 만들수 있는 방법이 여러가지가 된다는 이야기이다.
	
	***
	자바는 생성자 함수가 없어도 new 시킬수 있다.
	<== JVM이 기본 생성자 함수를 만들어 주기 때문에...
		단, 이경우에는 생성자 함수가 하나라도 존재하면 절대로 안되는 경우...
		
		
	생성자 함수 사용방법 ]
		생성자 함수는 그 클래스를 어떻게 인스턴스로 만들지(new 시킬지..) 알려주는 함수이다.
		즉, 생성자함수가 요구하는 매개변수가 무엇이지를 보면
		그 클래스의 인스턴스를 생성할 수 잇는 방법이 나온다.
		
	참고]
		클래스를 제작할 때는 이런 이유때문에
		그 클래스의 인스턴스를 만들 수 잇는 다양한 방식을 
		생성자 함수를 통해서 만들어 주는 것이 좋다.
		
	참고]
		this	: 현재 실행되는 객체 자기자신을 가리키는 예약어
		
		
		this()( 참고] super() )
		==> 생성자 함수는 원칙적으로 개발자가 직접 호출 할 수 없다.
			
			그런데 현재 클래스의 생성자를 실행하는 도중에 다른 생성자를 
			강제로 호출하는 유일한 방법
			
			*****
			규칙
				1. 반드시 생성자 안에서만 사용해야 한다.
					==> 일반 함수 안에서는 사용할 수 없다.
				2. 반드시 생성자 함수의 첫문장으로 사용해야 한다.
					==> 다른문장이 앞에 오면 에러가 발생한다.
 */
	
	
	Test01 t1 = new Test01(); 
	// 이것은 전혀 다른 객체 this 가 아니다. 
	// 굳이 따지자면 this의 멤버이다.
	
	private int no1;
	private int no2;
	private int no3;
	private int no4;
	private int no5;
	
	public Test01() {
		/*
		this.no1 = 10;
		this.no2 = 20;
		this.no3 = 30;
		this.no4 = 40;
		this.no5 = 50;
		이렇게 사용해도 무방하나 코드가 길어지고 ==> 가독성이 떨어지고
		객체지향적 방법은 아니게 된다.
		*/
//		this.Test01(10, 20, 30, 40, 50); ==> 이방법도 아니되옵니다.
		
//		this.no1 = 200;
		// this() 앞에 다른 문장이 오면 절대 안되기 때문에 에러......
		
		// 이럴 때 해결하는 방법이 this() 를 호출하는 방법
		this(10, 20, 30, 40, 50); 
		// 다른 형태로 정의 해놓은 생성자 함수를 호출할 수 있는 유일한 방법
		//	*******
		// 반드시 생성자함수의 첫문장으로만 사용할 수 있다.
		
	}
	
	public Test01(int no1, int no2, int no3, int no4, int no5) {
		this.no1 = no1; // 여기서의 this는 전역변수 no1과 매개변수 no1의 소속을 밝혀주기위해서...
		this.no2 = no2;
		this.no3 = no3;
		this.no4 = no4;
		this.no5 = no5;
	}
	
	
	public void abc() {
//		this(); // this() 는 생성자함수 내에서만 그리고 생성자함수 맨 첫문자으로 사용해야 한다.
		int num = this.no1;
	}

	public static void main(String[] args) {
		new Test01();
	}

}
