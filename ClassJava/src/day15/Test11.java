package day15;

import java.util.*;

/*
	Generic
		==> 컬렉션은 모든 형태의 데이터를 다 입력 받을 수 있다.
			(<== Object 타입으로 저장하니까...)
			하지만 실무에서는 한가지 형태로 입력받는 것을 원칙으로 한다.
			그런데 꺼낼때는 항상 형변환을 해서 꺼내야 한다.
			즉, 한가지 형태로 결정해서 데이터를 입력해 놓았는데
			꺼낼때는 자동 형변환이 되지 않기 때문에
			항상 강제형변환을 해줘야 한다.
			
		제너릭스란???
			==> 컬렉션에 입력되는 데이터의 형태를 미리 알려주고
				나중에 꺼내서 사용할 때 편하게 꺼낼 수 있도록 해주는 것.
				
			형식]
				ArrayList<String> list = new ArrayList<String>();
				
			참고]
				반드시 컬렉션마다 모두 제너릭스 선언을 해줘야 한다.
				
			참고]
				제너릭스는 전파되지 않는다.
				하나의 컬렉션에 제너릭스 선언이 되었더라도
				그 컬렉션을 이용하는 다른 컬렉션은 제너릭스를 없애버리게 된다.
				
				결론]
					새로운 컬렉션도 다시 제너릭스 선언을 해줘야 한다.
					
			
			참고]
				특수한 제너릭스
					==> 제너릭스의 본 목적은 특정 타입만 입력받을 목적으로 사용한다.
					
					형식]
						
						<? super 클래스이름>
							==> 클래스이름 포함 상위클래스까지 허락
						
						<? extends 클래스이름>
							==> 클래스이름 포함 하위클래스들 허락
							
						이 방법은 제너릭 선언을 하지 않는 것과 비슷한 효과가 있다.
						왜냐하면 형변환 해야 하니까.....
						
	==================================================================================================
	
		Annotation ( 어노테이션 )
			==> 내부적으로 약속도니 실행을 자동으로 처리하도록 하는 명령의 일종이다.
				
				주로
					화면에 실제 보이는 실행이 아니고
					점검(테스트)을 하던지
					선언적인 실행(이 클래스는 이런이런 방법으로 실행하세요...)
					의 의미를 가진 명령을 말한다.
					
				형식]
					
					@명령
				
 */

public class Test11 {

	public Test11() {
		HashSet<String> set = new HashSet<String>();
		
		set.add("둘리");
		set.add("희동이");
		set.add("또치");
		set.add("도우너");
		set.add("마이콜");
		set.add("고길동");
//		set.add(123); 
		// ==> 이 컬렉션에 입력되는 데이터를 문자열로 제한을 해놨기 때문에 
		//		문자열 이외의 데이터는 입력할 수 없다.
		
		// 꺼내서 출력
		// Iterator 로 변환하고
		Iterator<String> itor = set.iterator(); // 제너릭은 전파되지 않는다. 따라서 다시 선언...
		// 하나씩 꺼내서 출력한다.
		while(itor.hasNext()) {
			String str = itor.next();
			System.out.println(str);
		}
		
//		ArrayList<Object> list = new ArrayList<Object>(); //==> 제너릭 선언의 의미가 없다.
	}

	public static void main(String[] args) {
		new Test11();
	}

}
